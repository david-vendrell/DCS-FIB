<body>

  <h1>DCS – 4.1 & 4.2 Composite Béziers with Straight Lines</h1>

  <div class="controls">
    <button id="btn-new">New Curve</button>
    <button id="btn-del-point">Delete Last Point</button>
    <button id="btn-del-curve">Delete Last Curve</button>
    <button id="btn-reset">Reset All</button>
  </div>

  <div class="container">
    <div class="canvas-container">
      <canvas id="canvas1" width="800" height="600" style="border:1px solid #d3d3d3;"></canvas>
    </div>
    <div class="explanation-box">
      <h2>Composite Bézier Curves</h2>
      <p>Click to add <strong>anchor points</strong>. Drag points to reposition.  Curves automatically interpolate your anchors with C¹ continuity.</p>
      <p>Use the buttons above to start a new curve, undo the last point or curve, or reset completely.</p>
    </div>
  </div>

  <script>
    // -- state
    const curves = [];          // finished curves
    let current = { anchors: [], color: pickColor() };

    // canvas & style
    const canvas = document.getElementById('canvas1'),
          ctx    = canvas.getContext('2d'),
          style  = {
            gridSize: 50,
            curveWidth: 2,
            point: { radius: 6, lineWidth: 2, stroke: '#900', fill: 'rgba(200,200,200,0.5)' }
          };
    canvas.style.cursor = 'crosshair';

    // for dragging
    let dragIdx = null, dragCurve = null, lastMouse = null;

    // -- utility to pick a random pastel color
    function pickColor(){
      const hue = Math.floor(Math.random()*360);
      return `hsl(${hue}, 70%, 60%)`;
    }

    // -- Catmull–Rom to Bézier conversion
    function getSegments(anchors){
      const S = [];
      const n = anchors.length;
      if(n<2) return S;
      for(let i=0; i< n-1; i++){
        const P0 = anchors[i],
              P3 = anchors[i+1],
              Pm1= anchors[i-1] || P0,
              P2 = anchors[i+2] || P3;
        // handles at fraction 1/6 of chord
        const H1 = {
          x: P0.x + (P3.x - Pm1.x)/6,
          y: P0.y + (P3.y - Pm1.y)/6
        };
        const H2 = {
          x: P3.x - (P2.x - P0.x)/6,
          y: P3.y - (P2.y - P0.y)/6
        };
        S.push({ p0:P0, p1:H1, p2:H2, p3:P3 });
      }
      return S;
    }

    // -- drawing routines
    function drawGrid(){
      ctx.strokeStyle = 'lightgray';
      ctx.lineWidth = 1;
      for(let x=0; x<=canvas.width; x+=style.gridSize){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
      }
      for(let y=0; y<=canvas.height; y+=style.gridSize){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
      }
    }

    function drawCurve(curve){
      const segs = getSegments(curve.anchors);
      if(!segs.length) return;
      
      // Dibujar líneas rectas entre puntos de anclaje
      if(curve.anchors.length >= 2) {
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)'; // Línea recta en negro con transparencia
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(curve.anchors[0].x, curve.anchors[0].y);
        for(let i = 1; i < curve.anchors.length; i++) {
          ctx.lineTo(curve.anchors[i].x, curve.anchors[i].y);
        }
        ctx.stroke();
      }
      
      // Dibujar curva Bézier
      ctx.strokeStyle = curve.color;
      ctx.lineWidth = style.curveWidth;
      ctx.beginPath();
      ctx.moveTo(segs[0].p0.x, segs[0].p0.y);
      segs.forEach(s => {
        ctx.bezierCurveTo(
          s.p1.x,s.p1.y,
          s.p2.x,s.p2.y,
          s.p3.x,s.p3.y
        );
      });
      ctx.stroke();
    }

    function drawPoints(anchors){
      anchors.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x,p.y,style.point.radius,0,2*Math.PI);
        ctx.fillStyle = style.point.fill;
        ctx.fill();
        ctx.lineWidth = style.point.lineWidth;
        ctx.strokeStyle = style.point.stroke;
        ctx.stroke();
      });
    }

    function redraw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawGrid();
      // finished curves
      curves.forEach(c=> {
        drawCurve(c);
        drawPoints(c.anchors);
      });
      // current
      drawCurve(current);
      drawPoints(current.anchors);
    }

    // -- mouse helpers
    function getMouse(e){
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    function hitTest(pt, anchors){
      return anchors.findIndex(p=>((p.x-pt.x)**2 + (p.y-pt.y)**2) < style.point.radius**2);
    }

    // -- events
    canvas.addEventListener('mousedown', e=>{
      const m = getMouse(e);
      // try dragging existing points (in current first, then past curves)
      let idx = hitTest(m, current.anchors);
      if(idx>=0){
        dragCurve = current; dragIdx = idx;
      } else {
        // look in finished curves
        for(let c of curves){
          idx = hitTest(m,c.anchors);
          if(idx>=0){
            dragCurve = c; dragIdx = idx;
            break;
          }
        }
      }
      if(dragIdx===null){
        // add new anchor to CURRENT
        current.anchors.push(m);
      }
      lastMouse = m;
      redraw();
    });

    canvas.addEventListener('mousemove', e=>{
      if(dragIdx!==null){
        const m = getMouse(e);
        dragCurve.anchors[dragIdx] = m;
        lastMouse = m;
        redraw();
      }
    });

    canvas.addEventListener('mouseup', e=>{
      dragIdx = null;
      dragCurve = null;
    });
    canvas.addEventListener('mouseout', e=>{
      dragIdx = null;
      dragCurve = null;
    });

    // -- button actions
    document.getElementById('btn-new').onclick = ()=>{
      if(current.anchors.length>0){
        curves.push(current);
        current = { anchors: [], color: pickColor() };
        redraw();
      } else if (current.anchors.length === 0) {
        // Si no hay puntos en la curva actual, simplemente cambiar el color
        current.color = pickColor();
        redraw();
      }
    };
    document.getElementById('btn-del-point').onclick = ()=>{
      if(current.anchors.length>0){
        current.anchors.pop();
        redraw();
      }
    };
    document.getElementById('btn-del-curve').onclick = ()=>{
      if(curves.length>0){
        curves.pop();
        redraw();
      }
    };
    document.getElementById('btn-reset').onclick = ()=>{
      curves.length = 0;
      current = { anchors: [], color: pickColor() };
      redraw();
    };

    // initial draw
    redraw();
  </script>

</body>
