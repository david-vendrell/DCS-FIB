<html> 
      <head> 
      <title>DCS - 5</title> 
      <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }
        .container {
            display: flex;
            width: 100%;
        }
        .canvas-container {
            flex: 1;
            min-width: 800px;
        }
        .sidebar {
            width: 500px;
            padding: 20px;
            background-color: #f5f5f5;
            border-left: 1px solid #ddd;
            height: 600px;
            overflow-y: auto;
        }
        h1 {
            padding: 10px;
            margin-bottom: 0;
        }
        .control-point {
            font-family: monospace;
            margin-bottom: 5px;
        }
        .math-formula {
            font-family: serif;
            margin: 10px 0;
        }
      </style>
      </head>

      <body>

      <h1>DCS - Lab 5 - Surfaces</h1>

      <div class="container">
        <div class="canvas-container" id="canvas-container">
            <!-- Three.js canvas will be appended here -->
        </div>
        <div class="sidebar">
            <h3>Justificación del Problema</h3>
            <p>Este programa renderiza una superficie de Bézier de grado 3×3 utilizando los siguientes puntos de control:</p>
            
            <h4>Puntos de Control:</h4>
            <div class="control-point">{Pi,0} = {(0,0,0), (3,0,3), (6,0,3), (9,0,0)}</div>
            <div class="control-point">{Pi,1} = {(0,2,2), (3,2,5), (6,2,5), (9,2,2)}</div>
            <div class="control-point">{Pi,2} = {(0,4,0), (3,4,3), (6,4,3), (9,4,0)}</div>
            <div class="control-point">{Pi,3} = {(0,6,6), (3,6,5), (6,6,3), (9,6,2)}</div>
            
            <h4>Fórmula de la Superficie de Bézier:</h4>
            <div class="math-formula">
                P(u,v) = Σ<sub>i=0</sub><sup>3</sup> Σ<sub>j=0</sub><sup>3</sup> P<sub>i,j</sub>B<sub>i</sub>(u)B<sub>j</sub>(v)
            </div>
            
            <p>Donde B<sub>i</sub>(t) son los polinomios de Bernstein:</p>
            <div class="math-formula">
                B<sub>0</sub>(t) = (1-t)<sup>3</sup><br>
                B<sub>1</sub>(t) = 3t(1-t)<sup>2</sup><br>
                B<sub>2</sub>(t) = 3t<sup>2</sup>(1-t)<br>
                B<sub>3</sub>(t) = t<sup>3</sup>
            </div>
            
            <p>La superficie se ha centrado en el origen y escalado por un factor de 3 para mejorar la visualización.</p>
        </div>
      </div>
      
      <br>
      <div style="padding: 0 10px;">
          Note: X axis is red, Y axis is green, Z axis is blue.
          Each grid square on the plane Y=0 has size 10x10.
      </div>

      <script src="math.min.js"></script>
      <script src="three.min.js"></script>
      <script src="OrbitControlsDCS.js"></script>
    
     <script type="text/javascript">
        /**
        * Partially based on code by Ikaros Kappler from http://int2byte.de/public/blog.20160129_Three.js_Basic_Scene_Setup/
        **/
		var windowWidth=800.0, windowHeight=600.0;
		
        // Create a scene
        this.scene = new THREE.Scene();

        // Create a camera 
		// Parameters: vertical field of view, aspect ratio, near-clipping plane, far-clipping plane
		var camera = new THREE.PerspectiveCamera(45, windowWidth / windowHeight, 0.1, 1000);

        // Create a THREE renderer 
        this.renderer = new THREE.WebGLRenderer( { antialias : true, alpha:true } );
        this.shadowMapEnabled = true;
        this.renderer.setSize(windowWidth, windowHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement); // append it to our container
		
        // position and point the camera to the center of the scene (0,0,0)
        camera.position.x = 50;
        camera.position.y = 60;
        camera.position.z = 50;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

		// Create light, with same position and direction as camera
        this.spotLight = new THREE.SpotLight(0xffffff);
		this.spotLight.position.copy(camera.position)
		this.spotLight.target.position.copy (camera.lookAt); 
        scene.add(spotLight);

		
		/**** Here is where the important stuff is: definition of parametric geometry ****/
		// Examples of three parametric surface functions

		// Note: the parametric functions will be evaluated only on [0,1] x [0,1]
		// The function is called like this:
		// for v=0 to 1 step ...
		//    for u=0 to 1  step...
		//        call function(u,v)		
		
		// 4×4 control‐point grid P[i][j]
        var controlPoints = [
        [ new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 2, 2), new THREE.Vector3(0, 4, 0), new THREE.Vector3(0, 6, 6) ],
        [ new THREE.Vector3(3, 0, 3), new THREE.Vector3(3, 2, 5), new THREE.Vector3(3, 4, 3), new THREE.Vector3(3, 6, 5) ],
        [ new THREE.Vector3(6, 0, 3), new THREE.Vector3(6, 2, 5), new THREE.Vector3(6, 4, 3), new THREE.Vector3(6, 6, 3) ],
        [ new THREE.Vector3(9, 0, 0), new THREE.Vector3(9, 2, 2), new THREE.Vector3(9, 4, 0), new THREE.Vector3(9, 6, 2) ]
        ];

        // Cubic Bernstein polynomials
        function bernstein(i, t) {
        switch(i) {
            case 0: return (1 - t) * (1 - t) * (1 - t);
            case 1: return 3 * t * (1 - t) * (1 - t);
            case 2: return 3 * t * t * (1 - t);
            case 3: return t * t * t;
        }
        }

        // Bézier‐surface parametrization on [0,1]×[0,1] with scale factor
        function bezierSurfaceFunction(u, v) {
        var pt = new THREE.Vector3(0, 0, 0);
        var scale = 3; 
        

        var maxX = 9, minX = 0, maxZ = 6, minZ = 0;
        var centerX = (maxX + minX) / 2;
        var centerZ = (maxZ + minZ) / 2;
        
        for (var i = 0; i < 4; i++) {
            var bi = bernstein(i, u);
            for (var j = 0; j < 4; j++) {
            var bj = bernstein(j, v);
            // accumulate weighted control‐point with scale
            pt.x += controlPoints[i][j].x * bi * bj * scale;
            pt.y += controlPoints[i][j].y * bi * bj * scale;
            pt.z += controlPoints[i][j].z * bi * bj * scale;
            }
        }
        
        // Centramos la superficie (similar a bezierSurfaceCentered)
        pt.x -= centerX * scale;
        pt.z -= centerZ * scale;
        
        return pt;
        }

        // Create the mesh with improved centering
        function createMesh(geom) {
        // Ya no necesitamos aplicar la traslación ya que la superficie está centrada
        var mat = new THREE.MeshLambertMaterial({ 
            color: 0xff5555,
            side: THREE.DoubleSide,
            wireframe: false
        });
        return THREE.SceneUtils.createMultiMaterialObject(geom, [ mat ]);
        }

        /**** plug‐in Bézier surface here ****/
        this.functionExtent = 60;      
        var slides = functionExtent/3;    // Ajustamos la resolución según functionExtent
        var stacks = functionExtent/3;    // Ajustamos la resolución según functionExtent

        // Switch from plane/wave/ellipsoid to our Bézier
        var parametricFunction = bezierSurfaceFunction;

        var graphGeometry = new THREE.ParametricGeometry(
        parametricFunction,
        slides,
        stacks
        );

        this.scene.add(createMesh(graphGeometry));

		/****************************/
		
		// Auxiliary things
		
        // Add grid helper
		var gridExtent=80;
        var gridHelper = new THREE.GridHelper( gridExtent, gridExtent/10 );
        gridHelper.colorGrid = 0xE8E8E8;
        this.scene.add( gridHelper );

        // Add an axis helper
        var ah = new THREE.AxisHelper(50);
        ah.position.y -= 0.1;  // The axis helper should not interfere with the grid helper
        this.scene.add( ah );

        // Add an orbit control helper, to navigate scence with mosue
        var _self = this;
        this.orbitControls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
        // Always move the point light with the camera. Looks much better ;)
        this.orbitControls.addEventListener( 'change',
        function() { _self.spotLight.position.copy(_self.camera.position); }
        );
        this.orbitControls.enableDamping = true;
        this.orbitControls.dampingFactor = 1.0;
        this.orbitControls.enableZoom    = true;
        this.orbitControls.target.copy(new THREE.Vector3(0, 0, 0));

        // This is the basic render function. It will be called perpetual, again and again,
        // depending on your machines possible frame rate.
        this._render = function () {
            // Pass the render function itself
            requestAnimationFrame(this._render);
            this.renderer.render(this.scene, this.camera);
        };

        // Call the rendering function. This will cause an infinite recursion
        this._render();
		
	  </script>
      <br>
      </body>

      </html>